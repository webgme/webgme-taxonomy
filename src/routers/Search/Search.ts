/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Wed Aug 03 2022 22:46:01 GMT-0500 (Central Daylight Time).
 * To use in webgme add to gmeConfig.rest.components[Search] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './Search'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

"use strict";

// http://expressjs.com/en/guide/routing.html
import * as express from "express";
const router = express.Router();

import type { Request, Response } from "express";
import SystemTerm from "./SystemTerm";
import UploadContext, { FileUpload } from "./UploadContext";
import RouterUtils, {
  getFormatter,
  handleUserErrors,
  responseClose,
} from "../../common/routers/Utils";
import type {
  AzureGmeConfig,
  GmeContentContext,
  GmeContext,
  MiddlewareOptions,
} from "../../common/types";
import { toArtifactMetadatav2 } from "./adapters/common/Helpers";
import Utils from "../../common/Utils";
import { deepMerge, fromResult, isString } from "./Utils";
import DashboardConfiguration from "../../common/SearchFilterDataExporter";
import TagFormatter, { FormatError } from "../../common/TagFormatter";
import path from "path";
import fsp from "fs/promises";
const staticPath = path.join(__dirname, "dashboard", "public");
import StorageAdapter from "./adapters";
import {
  ChildContentTypeNotFoundError,
  MetaNodeNotFoundError,
} from "./adapters/common/ModelError";
import JSONSchemaExporter from "../../common/JSONSchemaExporter";
import TaskQueue, { DownloadTask, FilePath } from "./TaskQueue";
import { Option } from "oxide.ts";
import {
  Adapter,
  ArtifactMetadata,
  ArtifactMetadatav2,
  UploadReservation,
} from "./adapters/common/types";
import { UserError } from "../../common/UserError";
import { GremlinAdapter } from "./adapters/metadata";

/* N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts: MiddlewareOptions) {
  const { ensureAuthenticated } = middlewareOpts;
  const logger = middlewareOpts.logger.fork("Search");
  logger.debug("initializing ...");

  const mainConfig = middlewareOpts.gmeConfig;

  // Ensure authenticated can be used only after this rule.
  // router.use("*", function (req, res, next) {
  // TODO: set all headers, check rate limit, etc.

  // This header ensures that any failures with authentication won't redirect.
  // res.setHeader("X-WebGME-Media-Type", "webgme.v1");
  // next();
  // });

  RouterUtils.addLatestVersionRedirect(middlewareOpts, router);

  // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
  router.use("*", ensureAuthenticated);

  router.use(
    RouterUtils.getContentTypeRoutes("static/"),
    express.static(staticPath),
  );

  // Perhaps the path should include the node ID, too...
  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "configuration.json",
    async function getConfiguration(
      webgmeContext,
      _req: Request,
      res: Response,
    ) {
      const { core, contentType } = webgmeContext;
      const configuration = await DashboardConfiguration.from(
        core,
        contentType,
      );
      configuration.project = webgmeContext.projectVersion;
      configuration.contentTypePath = core.getPath(contentType);
      res.json(configuration);
    },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "schema.json",
    async (webgmeContext, _request, response) => {
      const { root, core, contentType } = webgmeContext;
      const exporter = JSONSchemaExporter.from(core, root);
      const vocabularies = await Utils.getVocabulariesFor(core, contentType);
      const name = core.getAttribute(contentType, "name")?.toString() ?? "";
      const { schema } = await exporter.getVocabSchemas(
        vocabularies,
        name,
        true,
      );
      response.json(schema);
    },
  );

  // Accessing and updating data via the storage adapter
  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/",
    async function listRepos(webgmeContext, req, res) {
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      const artifacts = await storage.listRepos();
      res.status(200).json(artifacts).end();
    },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:repoId",
    async function listArtifacts(webgmeContext, req, res) {
      const { repoId } = req.params;
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      // TODO: add support for repos that just reference another repo
      const artifacts = await storage.listArtifacts(repoId);
      // Print the tags... Are they the correct type?
      console.log(artifacts[0]);
      res.status(200).json(artifacts).end();
    },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/",
    async function createRepo(gmeContext, req, res) {
      const userId = middlewareOpts.getUserId(req);
      let metadata: ArtifactMetadatav2 = getArtifactMetadata(
        gmeContext,
        <ArtifactMetadata> req.body.metadata,
      );

      // Upload to the storage backend
      const storage = await StorageAdapter.from(
        gmeContext,
        req,
        mainConfig,
      );
      const status = await storage.withRepoReservation(
        async (reservation) => {
          await addSystemTags(
            metadata,
            reservation,
            gmeContext,
            userId,
            [], // repos are not initialized with any files
          );
          await toGuidFormat(
            gmeContext,
            metadata,
          );
          // TODO: should we upload to the graph db here?
          return await storage.createArtifact(reservation, metadata);
        },
      );

      res.json("status: " + status);
    },
    { method: "post" },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:repoId/append",
    async function appendContent(gmeContext, req, res) {
      const userId = middlewareOpts.getUserId(req);
      let metadata: ArtifactMetadatav2 = getArtifactMetadata(
        gmeContext,
        <ArtifactMetadata> req.body.metadata,
      );

      const { repoId } = req.params;
      const storage = await StorageAdapter.from(
        gmeContext,
        req,
        mainConfig,
      );

      const appendResult = await storage.withContentReservation(
        async (reservation) => {
          const filenames = req.body.filenames;
          await addChildSystemTags(
            metadata,
            reservation,
            gmeContext,
            userId,
            filenames,
          );
          await toGuidFormat(
            gmeContext,
            metadata,
          );
          return await storage.appendArtifact(
            reservation,
            metadata,
            filenames,
          );
        },
        repoId,
      );

      appendResult.files.forEach((file) => {
        const isRelative = file.params.url.startsWith("./");
        if (isRelative) {
          const baseUrl = req.originalUrl
            .split(`artifacts/${repoId}/append`)
            .shift();
          file.params.url = baseUrl + file.params.url.substring(2);
        }
      });
      res.json(appendResult);
    },
    { method: "post" },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:repoId/:id/:fileId/upload",
    async function uploadFile(webgmeContext, req, res) {
      const { repoId, id, fileId } = req.params;
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      if (storage.uploadFile) {
        const status = await storage.uploadFile(repoId, id, fileId, req);
        res.json(status);
      } else {
        res.sendStatus(400);
      }
    },
    { method: "post" },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:parentId/files/",
    async function downloadContentURL(webgmeContext, req, res) {
      const { parentId } = req.params;
      // TODO: get the IDs for the specific observations to get
      let ids;
      if (isString(req.query.ids)) {
        ids = JSON.parse(req.query.ids);
      } else {
        res.status(400).send("List of artifact IDs required");
        return;
      }

      //const formatter = await getFormatter(req.webgmeContext);
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );

      // need to download the urls of the associated observations ids
      const urlResponse = await storage.downloadFileURLs(parentId, ids);
      res.json(urlResponse);
    },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:parentId/:id/metadata.json",
    async function getMetadata(webgmeContext, req, res) {
      const { parentId, id } = req.params;
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      const metadataOpt = await storage.getMetadata(
        parentId,
        id,
      );

      const formatter = await getFormatter(webgmeContext);
      const metadata = fromResult(
        metadataOpt
          .map((md) => {
            md.tags = formatter.toHumanFormat(md.tags);
            return md;
          })
          .okOrElse(() => new UserError("Metadata not found", 404)),
      );

      res.json(metadata);
    },
  );
  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:parentId/:id",
    async function disableContent(webgmeContext, req, res) {
      const { parentId, id } = req.params;
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );

      await storage.disableArtifact(parentId, id);
      res.sendStatus(200);
    },
    { method: "delete" },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:parentId/metadata.jsonl",
    async function getBulkMetadata(webgmeContext, req, res) {
      const { parentId } = req.params;
      let ids: string[];
      if (isString(req.query.ids)) {
        ids = JSON.parse(req.query.ids);
      } else {
        res.status(400).send("List of artifact IDs required");
        return;
      }
      const MAX_THRESHOLD = 20000;
      if (ids.length > MAX_THRESHOLD) {
        res.status(400).send("Too many content IDs");
        return;
      }

      const formatter = await getFormatter(webgmeContext);
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      const metadata = await storage.getBulkMetadata(
        parentId,
        ids,
        formatter,
      );

      const metadataLines = metadata
        .map((md) => JSON.stringify(md))
        .join("\n");

      res.send(metadataLines);
    },
  );

  const downloadQueue: TaskQueue<DownloadTask, FilePath> = new TaskQueue();

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:repoId/downloads/",
    async function downloadContent(webgmeContext, req, res) {
      const { repoId } = req.params;
      // TODO: get the IDs for the specific observations to get
      let ids;
      if (isString(req.query.ids)) {
        ids = JSON.parse(req.query.ids) as string[];
      } else {
        res.status(400).send("List of artifact IDs required");
        return;
      }
      const formatter = await getFormatter(webgmeContext);
      const storage = await StorageAdapter.from(
        webgmeContext,
        req,
        mainConfig,
      );
      // Fetch all the metadata
      const contentIds = ids.sort((id1, id2) => +id1 < +id2 ? -1 : 1);
      const allMetadata = await Promise.all(
        contentIds.map(async (contentId) => {
          const metadata = await storage.getMetadata(
            repoId,
            contentId,
          );
          return metadata.map((md) => {
            try {
              md.tags = formatter.toHumanFormat(md.tags);
            } catch (err) {
              logger.warn(
                `Unable to convert tags to human format: ${contentId} (${repoId})`,
              );
              throw err;
            }
            return md;
          });
        }),
      );
      const metadata = allMetadata
        .filter((metadata) => metadata.isSome())
        .map((metadata) => metadata.unwrap());

      // get all the metadata in human format
      const task = new DownloadTask(
        mainConfig as AzureGmeConfig,
        logger,
        req,
        metadata,
        () => getRepositoryName(logger, repoId, storage, formatter),
      );
      const id = downloadQueue.submitTask(task);
      res.json(id);
    },
    { method: "post" },
  );

  async function getRepositoryName(
    logger: Global.GmeLogger,
    repoId: string,
    storage: Adapter,
    formatter: TagFormatter,
  ): Promise<string> {
    const metadata = await storage.getRepoMetadata(repoId);
    const tags = formatter.toHumanFormat(metadata.tags);
    return Option.from(tags.Base?.name?.value as string)
      .unwrapOrElse(() => {
        logger.info(
          `No "Base.name" tag found for ${repoId}. Using ID instead.`,
        );
        return repoId;
      });
  }

  router.get(
    RouterUtils.getContentTypeRoutes(
      "artifacts/:parentId/downloads/:taskId/status",
    ),
    handleUserErrors(
      logger,
      async function getDownloadTaskStatus(req, res) {
        const { taskId } = req.params;
        const status = downloadQueue.getStatus(parseInt(taskId));
        res.json(status);
      },
    ),
  );

  router.get(
    RouterUtils.getContentTypeRoutes(
      "artifacts/:parentId/downloads/:taskId",
    ),
    handleUserErrors(
      logger,
      async function getDownloadContent(req, res) {
        const { taskId } = req.params;
        const zipPath = fromResult(downloadQueue.getResult(parseInt(taskId)));
        const tmpDir = path.dirname(zipPath);

        res.download(
          zipPath,
          path.basename(zipPath),
        );

        await responseClose(res);
        await fsp.rm(tmpDir, { recursive: true });
      },
    ),
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "artifacts/:repoId/:id",
    async function updateContent(gmeContext, req, res) {
      const userId = middlewareOpts.getUserId(req);
      const { repoId, id } = req.params;
      const storage = await StorageAdapter.from(
        gmeContext,
        req,
        mainConfig,
      );
      let metadata: ArtifactMetadatav2 = getArtifactMetadata(
        gmeContext,
        <ArtifactMetadata> req.body.metadata,
      );

      // update the content
      const updateResult = await storage.withUpdateReservation(
        async (reservation) => {
          const filenames = req.body.filenames;
          await addChildSystemTags(
            metadata,
            reservation,
            gmeContext,
            userId,
            filenames,
          );
          await toGuidFormat(
            gmeContext,
            metadata,
          );
          return await storage.updateArtifact(
            reservation,
            metadata,
            filenames,
          );
        },
        repoId,
        id,
      );

      updateResult.files.forEach((file) => {
        const isRelative = file.params.url.startsWith("./");
        if (isRelative) {
          const baseUrl = req.originalUrl
            .split(`artifacts/${repoId}/${id}`)
            .shift();
          file.params.url = baseUrl + file.params.url.substring(2);
        }
      });

      res.json(updateResult);
    },
    { method: "post" },
  );

  RouterUtils.addContentTypeRoute(
    middlewareOpts,
    router,
    "gremlin",
    async function runGremlin(webgmeContext, req, res) {
      // TODO: get the IDs for the specific observations to get
      // TODO: run a gremlin query
      // TODO: load the metadata
      //const gremlin = <string> req.body.gremlin;
      // TODO: pass this along to the graph DB

      //const formatter = await getFormatter(webgmeContext);
      //const storage = new GremlinAdapter();
      //storage.
      // Fetch all the metadata
      throw new Error("Unimplemented!");
      //res.json(id);
    },
    { method: "post" },
  );

  logger.debug("ready");
}

/**
 * Add the system terms using the child of the content type defined in the
 * URL. Useful when appending data to an existing content type as the
 * content type from the URL is the parent (ie, repo) rather than the
 * content in the repo.
 */
async function addChildSystemTags(
  metadata: ArtifactMetadatav2,
  reservation: UploadReservation,
  gmeContext: GmeContentContext,
  userId: string,
  filenames: string[],
) {
  const { core, contentType } = gmeContext;
  const childContentType = (await core.loadChildren(contentType))
    .find((n) =>
      core.getAttribute(core.getBaseType(n), "name") === "Content Type"
    );

  if (!childContentType) {
    throw new ChildContentTypeNotFoundError(gmeContext, contentType);
  }

  return addContentTypeSystemTags(
    childContentType,
    metadata,
    reservation,
    gmeContext,
    userId,
    filenames,
  );
}

async function addSystemTags(
  metadata: ArtifactMetadatav2,
  reservation: UploadReservation,
  gmeContext: GmeContentContext,
  userId: string,
  filenames: string[],
) {
  const { contentType } = gmeContext;

  return addContentTypeSystemTags(
    contentType,
    metadata,
    reservation,
    gmeContext,
    userId,
    filenames,
  );
}

async function addContentTypeSystemTags(
  contentType: Core.Node,
  metadata: ArtifactMetadatav2,
  reservation: UploadReservation,
  gmeContext: GmeContentContext,
  userId: string,
  filenames: string[] = [],
) {
  const { core, projectVersion } = gmeContext;
  const children = await core.loadChildren(contentType);
  const vocabs = children
    .find((node: Core.Node) =>
      core.getAttribute(core.getBaseType(node), "name") === "Vocabularies"
    ) || getVocabulariesMetaNode(core, contentType);

  if (!vocabs) {
    throw new MetaNodeNotFoundError(gmeContext, "Vocabularies");
  }

  const systemTerms = await SystemTerm.findAll(core, vocabs);
  const desc = ""; // TODO: add description
  const files: FileUpload[] = filenames.map((path: string) => ({
    path,
  }));
  const uri: string | undefined = reservation.uri;

  // TODO: write some tests for this
  const context = await UploadContext.from({
    name: metadata.displayName,
    description: desc,
    tags: metadata.tags,
    files,
    core,
    contentType,
    project: projectVersion,
    userId,
    uri,
  });

  const systemTags =
    (await Promise.all(systemTerms.map((t) => t.createTags(context)))).flat();

  // TODO: refactor this to make it easier to test...
  metadata.tags = deepMerge(metadata.tags, ...systemTags);
}

/**
 * Get the "Vocabularies" node from the metamodel as it contains the default vocabularies
 * defined for every content type.
 */
function getVocabulariesMetaNode(
  core: GmeClasses.Core,
  someNode: Core.Node,
): Core.Node | undefined {
  const metanodes = Object.values(core.getAllMetaNodes(someNode));
  const vocabNode = metanodes.find((node) =>
    core.getAttribute(node, "name") === "Vocabularies"
  );

  return vocabNode;
}

/**
 * Convert the taxonomy tags in the metadata to GUID format.
 */
async function toGuidFormat(
  gmeContext: GmeContentContext,
  metadata: ArtifactMetadatav2,
): Promise<ArtifactMetadata> {
  const formatter = await getFormatter(gmeContext);
  try {
    // TODO: validate them, first?
    metadata.tags = formatter.toGuidFormat(metadata.tags);
    return metadata;
  } catch (err) {
    // A stop-gap solution until FormatError actually inherits from UserError
    if (err instanceof FormatError) {
      throw new UserError(err.message);
    } else {
      throw err;
    }
  }
}

/**
 * Retrieve the artifact metadata from the request. Initialize it if none provided.
 */
function getArtifactMetadata(
  gmeContext: GmeContext,
  metadata: ArtifactMetadata,
): ArtifactMetadatav2 {
  const projectVersion = gmeContext.projectVersion;

  // TODO: check if it is a tags file...
  const metadatav2 = toArtifactMetadatav2(metadata);

  // TODO: check if the project version and metadata tags are compatible
  // if not, throw a UserError
  metadatav2.tags = metadatav2.tags || {};
  metadatav2.taxonomyVersion = projectVersion;

  return metadatav2;
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback: () => void) {
  callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback: () => void) {
  callback();
}

module.exports = {
  initialize: initialize,
  router: router,
  start: start,
  stop: stop,
};
