/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Mon May 01 2023 10:38:09 GMT-0500 (Central Daylight Time).
 * To use in webgme add to gmeConfig.rest.components[Profiles] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './Profiles'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

"use strict";

import { unique } from "../Search/Utils";
import { makeCore } from "../../common/routers/Utils";
import { toString } from "../../common/Utils";
import { MiddlewareOptions } from "../../common/types";
import type { ProjectMetadata } from "webgme";
import { NextFunction, Request, Response } from "express";
import express from "express";
const router = express.Router();

/**
 * Called when the server is created but before it starts to listening to incoming requests.
 * N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts: MiddlewareOptions) {
  var logger = middlewareOpts.logger.fork("Profiles"),
    ensureAuthenticated = middlewareOpts.ensureAuthenticated;

  const { gmeAuth, safeStorage } = middlewareOpts;

  logger.debug("initializing ...");

  // Ensure authenticated can be used only after this rule.
  router.use("*", function (_req: Request, res: Response, next: NextFunction) {
    // This header ensures that any failures with authentication won't redirect.
    res.setHeader("X-WebGME-Media-Type", "webgme.v1");
    next();
  });

  // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
  router.use("*", ensureAuthenticated);

  // Get a list of profiles visible by the current user
  router.get("/", async function (req: Request, res: Response /*, next*/) {
    const userId = middlewareOpts.getUserId(req);
    const projects = await safeStorage.getProjects({
      info: true,
      branches: true,
    });

    // Filter out all non-trusted (admin or self) projects
    const profiles = projects.filter((project) => {
      const isProfile = project.info.kind === "profile";
      return isProfile && !!project.branches.master;
    });

    const owners = await Promise.all(
      unique(profiles.map((project) => project.owner)).map((name) =>
        gmeAuth.getUser(name)
      ),
    );
    const trustedOwners = new Set(
      owners.filter((owner) => owner.siteAdmin).map((user) => user._id),
    );
    trustedOwners.add(userId);

    const trustedProfiles = profiles.filter((profile) =>
      trustedOwners.has(profile.owner)
    );

    // Collect all the profiles defined in these projects and return them as JSON
    const profileJSONs = await Promise.all(trustedProfiles.map(getProfiles));
    const profileDict: { [name: string]: ProfileData } = Object.fromEntries(
      profileJSONs
        .flat()
        .map((
          profile,
        ) => [profile.name, {
          project: profile.project,
          version: profile.version,
          URL: profile.URL,
        }]),
    );

    res.json(profileDict);
  });

  async function getProfiles(
    projectInfo: ProjectMetadata,
  ): Promise<Profile[]> {
    // Set up the core and load the root node
    const project = await safeStorage.openProject({
      projectId: projectInfo._id,
    });
    const core = makeCore(project, middlewareOpts);
    const rootHash = await project.getRootHash("master");
    const root = await core.loadRoot(rootHash);

    // find the profile definitions
    const nodes = await core.loadChildren(root);
    const profiles = nodes.filter((node) => {
      const base = core.getBaseType(node);
      return core.getAttribute(base, "name") === "Profile";
    });

    // convert the nodes to JSON
    return profiles.map((node) => {
      // TODO: remove empty strings
      const profileData: Profile = {
        name: toString(core.getAttribute(node, "name")),
        project: toString(core.getAttribute(node, "project")),
        version: toString(core.getAttribute(node, "version")),
      };
      const url = toString(core.getAttribute(node, "URL"));
      if (url && url !== "") {
        profileData.URL = url;
      }
      return profileData;
    });
  }

  logger.debug("ready");
}

interface Profile {
  name: string;
  project: string;
  version: string;
  URL?: string;
}

interface ProfileData {
  project: string;
  version: string;
  URL?: string;
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback: () => void) {
  callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback: () => void) {
  callback();
}

module.exports = {
  initialize: initialize,
  router: router,
  start: start,
  stop: stop,
};
