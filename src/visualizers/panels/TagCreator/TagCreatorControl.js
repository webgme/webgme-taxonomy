/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri Jun 24 2022 16:26:14 GMT-0500 (Central Daylight Time).
 */

define([
  "js/Constants",
  "js/Utils/GMEConcepts",
  "webgme-taxonomy/Utils",
  "js/NodePropertyNames",
  "q",
], function (
  CONSTANTS,
  GMEConcepts,
  Utils,
  nodePropertyNames,
  Q,
) {
  const TAG_SET_NAMES = "taxonomyTags";
  "use strict";

  function TagCreatorControl(options) {
    this._logger = options.logger.fork("Control");

    this._client = options.client;

    // Initialize core collections and variables
    this._widget = options.widget;

    this._currentNodeId = null;
    this._currentNodeParentId = undefined;

    this._initWidgetEventHandlers();

    this._logger.debug("ctor finished");
  }

  TagCreatorControl.prototype._initWidgetEventHandlers = function () {
    this._widget.addTags = async (taxonomyPath, formData) => {
      this.markDisabled();
      const activeNodeId = this._currentNodeId;
      const { core, rootNode } = await this._getCoreInstance();
      const activeNode = await core.loadByPath(rootNode, activeNodeId);
      const taxonomyNode = await core.loadByPath(rootNode, taxonomyPath);
      const nodesByGuid = Object.fromEntries(
        (await core.loadSubTree(taxonomyNode)).map((node) => [
          core.getGuid(node),
          node,
        ]),
      );

      // remove existing members
      const existingMemberPaths = core.getMemberPaths(
        activeNode,
        TAG_SET_NAMES,
      );
      existingMemberPaths.forEach((memberPath) =>
        core.delMember(activeNode, TAG_SET_NAMES, memberPath)
      );

      // add new members
      const tags = formData.tags;
      tags.forEach((tagInfo) => {
        const tagNode = nodesByGuid[tagInfo.ID];
        core.addMember(activeNode, TAG_SET_NAMES, tagNode);

        const attributeNames = _.without(Object.keys(tagInfo), "ID");
        const tagPath = core.getPath(tagNode);
        attributeNames.forEach((name) => {
          const value = tagInfo[name];
          core.setMemberAttribute(
            activeNode,
            TAG_SET_NAMES,
            tagPath,
            name,
            value,
          );
        });
      });

      // save
      const { rootHash, objects } = core.persist(rootNode);
      const branch = this._client.getActiveBranchName();
      const startCommit = this._client.getActiveCommitHash();
      const project = this._client.getProjectObject();

      const tagNames = tags
        .map((tagInfo) => {
          const tagNode = nodesByGuid[tagInfo.ID];
          return core.getAttribute(tagNode, "name");
        })
        .join(", ");
      const activeNodeName = core.getAttribute(activeNode, "name");
      const commitMsg = `Set taxonomy tags on ${activeNodeName} to ${tagNames}`;

      await project.makeCommit(
        branch,
        [startCommit],
        rootHash,
        objects,
        commitMsg,
      );
    };
  };

  TagCreatorControl.prototype.markDisabled = function () {
    console.error(
      `In an effort to focus on the main features of the taxonomy design studio, usage of the tag form within WebGME has been temporarily disabled. If this is a problem for you, please open an issue and restoring this functionality will be made a higher priority!`,
    );
    throw new Error("Tag form use from within webgme has been disabled.");
  };

  /* * * * * * * * Visualizer content update callbacks * * * * * * * */
  // One major concept here is with managing the territory. The territory
  // defines the parts of the project that the visualizer is interested in
  // (this allows the browser to then only load those relevant parts).
  TagCreatorControl.prototype.selectedObjectChanged = function (nodeId) {
    var desc = this._getObjectDescriptor(nodeId),
      self = this;

    self._logger.debug("activeObject nodeId '" + nodeId + "'");

    // Remove current territory patterns
    if (self._currentNodeId) {
      self._client.removeUI(self._territoryId);
    }

    self._currentNodeId = nodeId;
    self._currentNodeParentId = undefined;

    if (typeof self._currentNodeId === "string") {
      // Put new node's info into territory rules
      self._selfPatterns = {};
      self._selfPatterns[nodeId] = { children: 0 }; // Territory "rule"

      if (typeof desc.parentId === "string") {
        self.$btnModelHierarchyUp.show();
      } else {
        self.$btnModelHierarchyUp.hide();
      }

      self._currentNodeParentId = desc.parentId;

      self._territoryId = self._client.addUI(self, async () => {
        whileChain(
          () => nodeId === self._currentNodeId,
          [
            () =>
              Promise.all([
                this._getJSONSchemas(nodeId),
                this._getCurrentFormData(nodeId),
                this._getDownloadData(),
              ]),
            ([schemas, formData, downloadData]) => {
              const { taxonomyPath, schema, uiSchema } = schemas;
              this._widget.render(
                schema,
                uiSchema,
                formData,
                downloadData,
                taxonomyPath,
              );
            },
          ],
        );
      });

      // Update the territory
      self._client.updateTerritory(self._territoryId, self._selfPatterns);

      self._selfPatterns[nodeId] = { children: 1 };
      self._client.updateTerritory(self._territoryId, self._selfPatterns);
    }
  };

  TagCreatorControl.prototype._getDownloadData = async function () {
    return { taxonomyVersion: await this._getTaxonomyVersion() };
  };

  TagCreatorControl.prototype._getTaxonomyVersion = async function () {
    const taxonomyVersion = {
      id: this._client.getActiveProjectId(),
    };
    const tagDict = await Q.ninvoke(
      this._client,
      "getTags",
      taxonomyVersion.id,
    );
    const commitHash = this._client.getActiveCommitHash();
    const [tag] = Object.entries(tagDict).find(([_tag, hash]) =>
      hash === commitHash
    ) || [];
    const branch = this._client.getActiveBranchName();

    if (tag) {
      taxonomyVersion.tag = tag;
    } else if (branch) {
      taxonomyVersion.branch = branch;
    } else {
      taxonomyVersion.commit = commitHash;
    }
    taxonomyVersion.url = window.location.host;
    return taxonomyVersion;
  };

  async function whileChain(cond, chain) {
    let lastResult = null;
    while ((await cond()) && chain.length) {
      lastResult = await chain.shift()(lastResult);
    }
    return lastResult;
  }

  // This next function retrieves the relevant node information for the widget
  TagCreatorControl.prototype._getCurrentFormData = async function (nodeId) {
    console.log(`Getting form data for "${nodeId}"`);
    const node = this._client.getNode(nodeId);
    //if (!node) return;
    const supportsTags = node.getSetNames().includes(TAG_SET_NAMES);

    console.log({ supportsTags });
    if (supportsTags) {
      const memberPaths = node.getMemberIds(TAG_SET_NAMES);
      const memberAttrs = memberPaths.map((memberPath) => {
        const attrDict = Object.fromEntries(
          node
            .getMemberAttributeNames(TAG_SET_NAMES, memberPath)
            .map((name) => [
              name,
              node.getMemberAttribute(TAG_SET_NAMES, memberPath, name),
            ]),
        );
        return attrDict;
      });

      console.log({ memberPaths });
      const memberNodes = await this._loadNodes(memberPaths);
      const tags = await Promise.all(
        memberNodes.map((node, i) => this._getTagData(node, memberAttrs[i])),
      );
      return tags;
    }
  };

  TagCreatorControl.prototype._getTagData = function (memberNode, attrDict) {
    // TODO: update this
    const tag = {
      ID: memberNode.getGuid(),
    };
    Object.assign(tag, attrDict);
    return tag;
  };

  TagCreatorControl.prototype._loadNodes = async function (nodePaths) {
    const deferred = Q.defer();
    const territoryId = this._client.addUI(this, async () => {
      this._client.removeUI(territoryId);
      const nodes = nodePaths.map((nodePath) => this._client.getNode(nodePath));
      return deferred.resolve(nodes);
    });
    const territory = Object.fromEntries(
      nodePaths.map((path) => [path, { children: 0 }]),
    );
    this._client.updateTerritory(territoryId, territory);

    return deferred.promise;
  };

  TagCreatorControl.prototype._getObjectDescriptor = function (nodeId) {
    var node = this._client.getNode(nodeId),
      objDescriptor;
    if (node) {
      objDescriptor = {
        id: node.getId(),
        name: node.getAttribute(nodePropertyNames.Attributes.name),
        childrenIds: node.getChildrenIds(),
        parentId: node.getParentId(),
        isConnection: GMEConcepts.isConnection(nodeId),
      };
    }

    return objDescriptor;
  };

  /* * * * * * * * Node Event Handling * * * * * * * */
  TagCreatorControl.prototype._getJSONSchemas = async function () {
    const pluginId = "JSONSchemaExporter";
    const context = this._client.getCurrentPluginContext(pluginId);
    const results = await Q.ninvoke(
      this._client,
      "runServerPlugin",
      pluginId,
      context,
    );

    console.log({ results });
    // TODO: get the taxonomy data
    // return taxonomyData;
  };

  TagCreatorControl.prototype._getVocabularies = async function (
    core,
    root,
    activeNode,
  ) {
    const rootNode = core.getRoot(activeNode);
    const contentTypePath = core.getPointerPath(activeNode, "contentType");
    console.log("contentTypePath", contentTypePath);
    if (contentTypePath) {
      const contentType = await core.loadByPath(root, contentTypePath);
      return await Promise.all(
        core
          .getMemberPaths(contentType, "vocabularies")
          .map((path) => core.loadByPath(root, path)),
      );
    } else {
      const node = await Utils.findTaxonomyNode(core, rootNode);
      if (node) {
        return await core.loadChildren(node);
      } else {
        return [];
      }
    }
  };

  TagCreatorControl.prototype._getCoreInstance = async function () {
    return new Promise((res, rej) => {
      this._client.getCoreInstance({}, (err, result) => {
        if (err) return rej(err);
        res(result);
      });
    });
  };

  TagCreatorControl.prototype._toMetaDict = function (core, nodes) {
    return Object.fromEntries(
      nodes.map((node) => [core.getAttribute(node, "name"), node]),
    );
  };

  TagCreatorControl.prototype._stateActiveObjectChanged = function (
    model,
    activeObjectId,
  ) {
    if (this._currentNodeId === activeObjectId) {
      // The same node selected as before - do not trigger
    } else {
      this.selectedObjectChanged(activeObjectId);
    }
  };

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  TagCreatorControl.prototype.destroy = function () {
    this._detachClientEventListeners();
    this._removeToolbarItems();
  };

  TagCreatorControl.prototype._attachClientEventListeners = function () {
    this._detachClientEventListeners();
    WebGMEGlobal.State.on(
      "change:" + CONSTANTS.STATE_ACTIVE_OBJECT,
      this._stateActiveObjectChanged,
      this,
    );
  };

  TagCreatorControl.prototype._detachClientEventListeners = function () {
    WebGMEGlobal.State.off(
      "change:" + CONSTANTS.STATE_ACTIVE_OBJECT,
      this._stateActiveObjectChanged,
    );
  };

  TagCreatorControl.prototype.onActivate = function () {
    this._attachClientEventListeners();
    this._displayToolbarItems();

    if (typeof this._currentNodeId === "string") {
      WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {
        suppressVisualizerFromNode: true,
      });
    }
  };

  TagCreatorControl.prototype.onDeactivate = function () {
    this._detachClientEventListeners();
    this._hideToolbarItems();
  };

  /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
  TagCreatorControl.prototype._displayToolbarItems = function () {
    if (this._toolbarInitialized === true) {
      for (var i = this._toolbarItems.length; i--;) {
        this._toolbarItems[i].show();
      }
    } else {
      this._initializeToolbar();
    }
  };

  TagCreatorControl.prototype._hideToolbarItems = function () {
    if (this._toolbarInitialized === true) {
      for (var i = this._toolbarItems.length; i--;) {
        this._toolbarItems[i].hide();
      }
    }
  };

  TagCreatorControl.prototype._removeToolbarItems = function () {
    if (this._toolbarInitialized === true) {
      for (var i = this._toolbarItems.length; i--;) {
        this._toolbarItems[i].destroy();
      }
    }
  };

  TagCreatorControl.prototype._initializeToolbar = function () {
    var self = this,
      toolBar = WebGMEGlobal.Toolbar;

    this._toolbarItems = [];

    this._toolbarItems.push(toolBar.addSeparator());

    /************** Go to hierarchical parent button ****************/
    this.$btnModelHierarchyUp = toolBar.addButton({
      title: "Go to parent",
      icon: "glyphicon glyphicon-circle-arrow-up",
      clickFn: function (/*data*/) {
        WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
      },
    });
    this._toolbarItems.push(this.$btnModelHierarchyUp);
    this.$btnModelHierarchyUp.hide();

    /************** Checkbox example *******************/

    this._toolbarInitialized = true;
  };

  return TagCreatorControl;
});
